<?php

namespace AppBundle\Controller;

use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Exception;
use Symfony\Component\HttpFoundation\Request;
use AppBundle\Entity\City;
use Symfony\Component\Routing\RouterInterface;

/**
 * @Route(name="city_", path="/city")
 */
class CityController extends Controller
{
    /**
     * Je restreins cette route grâce à une regex dans requirements
     * (ici un nombre "d+")
     *
     * @Route(name="remove", path="/{id}", requirements={"id"="\d+"})
     */
    public function removeAction($id)
    {
        // La méthode redirectToRoute  permet de faire une redirection 302 vers une autre url
        return $this->redirectToRoute('city_list');
        return new Response('<html><body>Remove : '.$id.'</body></html>');
    }

    /**
     * J'ai fais le choix sur cette route, de définir un slash à la fin de l'rul
     * Si j'appelle /city/build, j'ai une redirection 301 vers /city/build/
     *
     * @Route(name="build", path="/build/")
     */
    public function buildAction()
    {
        return new Response("<html><body>Build !</body></html>");
    }

    /**
     * @Route(name="destroy", path="/destroy")
     */
    public function destroyAction()
    {
        return new Response('<html><body>Destroy !</body></html>');
    }

    /**
     * L'ordre des routes est important, si /list est après get
     * Le système va traiter list comme un slug
     *
     * @Route(name="list", path="/list")
     */
    public function listAction(RouterInterface $router)
    {
        // grâce à la méthode generateUrl on est en mesure de générer à la volée
        // une url vers une autre route en lui passant un tableau si besoin est.
//        $url = $this->generateUrl('city_remove', ['id'=>8]);

        // Si on hérite pas de Controller, on va pouvoir faire la même chose
        // grâce au service Router
//        $url = $router->generate('city_remove', ['id'=>9]);
//        return new Response('List cities <a href="'.$url.'">Supprimer !</a>');
        $cities = $this
            ->getDoctrine()
            ->getRepository(City::class)
            ->findAll()
        ;

        // on créé le QueryBuilder à partir de l'entitymanager
        $queryBuilder = $this
            ->getDoctrine()
            ->getManager()
            ->createQueryBuilder('c')
        ;

        // de facon chainée, on va venir créer notre Query
        // ensuite, on récupère notre Query
        $query = $queryBuilder
            ->select('c')
            ->from('AppBundle:City', 'c')
            ->where('c.population >= :population')
            ->where($queryBuilder->expr()->orX(
                $queryBuilder->expr()->gte('c.population', ':population'),
                $queryBuilder->expr()->like('c.name', ':name')
            ))
            ->setParameter('population', 100000)
            ->setParameter('name', '%nn%')
            ->getQuery()
        ;

        // une fois que l'on a notre query, on va etre capable de récupérer les résultats
        $cities = $query->getResult();

        // Maintenant on va fiare la meme chose mais avec du DQL
        // (Doctrine Query Langage)
        $dql = <<<DQL
SELECT c
FROM AppBundle:City c
WHERE c.population >= :population OR c.name LIKE :name
DQL;

        // C'est une autre façon de récupérer mes villes
        // plus simple et plus lisible
        $city = $this
            ->getDoctrine()
            ->getManager()
            ->createQuery($dql)
            ->setParameter('population', 100000)
            ->setParameter('name', '%nn%')
            ->setMaxResults(1)
            ->getOneOrNullResult()
        ;

        // En déplacant la query dans le repo, on peut la réutiliser
        // sans avoir à la réécrire.
        $cities = $this
            ->getDoctrine()
            ->getRepository(City::class)
            ->findCitiesWithPopulationGreaterThan100000()
        ;

        dump($city->getName());

        return $this->render('city/list.html.twig',
            ['cities'=> $cities]
        );
    }

    /**
     * @Route(name="load", path="/load")
     */
    public function loadAction()
    {
        $cities = [
            ['Nantes', 200000],
            ['Rennes', 160000],
            ['La Roche sur Yon', 60000],
            ['Angers', 80000],
        ];

        $entitymanager = $this
            ->getDoctrine()
            ->getManager()
        ;

        foreach ($cities as $data)
        {
            $city = new city();
            $city->setName($data[0]);
            $city->setPopulation($data[1]);
            //ici on fait un petit persist mais surtout pas de flush
            $entitymanager->persist($city);
        }
        //le flush doit etre après la boucle
        $entitymanager->flush();

        return new Response('<html><body>yop yop</body></html>');
    }

    /**
     * @Route(name="get", path="/{slug}")
     */
    public function getAction(Request $request, $slug)
    {
        // Si je tente de trouver $slug et ca n'existe pas :
//        throw $this->createNotFoundException("Exception : $slug");
//
//        // Si jamais il y a un gros pépin
//        throw new Exception("Error 500 : $slug");
//        return new Response('Get : '.$slug);

        // Si mon URL contient ?var=1 :
//        dump($request->get('var'));

        $request->getSession()->set('var',4);
        return new Response('<html><body>Get : '.$slug.'</body></html>');
    }
}